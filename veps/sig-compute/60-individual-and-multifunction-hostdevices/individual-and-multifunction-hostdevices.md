# VEP #60: Individual and Multifunction Host Devices  

## Release Signoff Checklist

Items marked with (R) are required *prior to targeting to a milestone / release*.

- [x] (R) Enhancement issue created, which links to VEP dir in [kubevirt/enhancements] (not the initial VEP PR)

## Overview  

This proposal aims to enhance KubeVirt's host devices interface by improving support for multifunction passthrough. These changes will maintain backward compatibility while providing additional flexibility in device assignment and power management.  

## Motivation  

KubeVirt's existing host devices interface is designed to provide a generic model for PCI passthrough, allowing VirtualMachines (VMs) to boot anywhere in the cluster. While this abstraction is valuable, it presents challenges in specific scenarios:  

**Improved Multifunction PCI Passthrough**  
- Some PCI devices expose multiple functions (e.g., a GPU with an integrated audio controller or a network card with multiple interfaces).  
- Inconsistent function allocation across different physical devices can affect performance and initialization.  
- Power management behavior varies between single-function and multi-function passthrough, affecting device readiness after VM boot.  

During single-function passthrough, a sequence of events occurs within the Linux kernel that completely cuts power to the PCIe slot. *In short, QEMU triggers Linux (VFIO) to reset each function and if possible it will issue a full slot or bus reset*  

When dealing with multifunction devices, a Kubernetes node may have multiple instances of the same multifunction PCI device. If a VirtualMachine requests two function devices, the scheduler may allocate one function from two different physical devices residing for example on two separate pcie slots.  

If this occurs, Linux will not cut power to the host device during passthrough, resulting in behavioral discrepancies compared to scenarios where both functions originate from the same device. *This difference in power state transitions can impact device initialization for certain hardware.*  

Passing the entire host device including all of its functions allows KubeVirt to be used in automated testing farms of pci host devices.  
This allows CI jobs and PCI driver developers to request a virtual machine with a host device and gain access to the entire device.  
For PCI driver development, it's crucial to boot a VM with a preserved PCI device tree mirroring the host system and to perform a bus reset prior to VM startup.  

## Goals  

- Allow booting a VM using an entire PCI device with all its associated functions.  

## Non-Goals  

- Support for live migration.  
- Preserve the PCI tree topology in the guest.  

## Definition of Users  

- VM owners.  
- cluster admins.  

## User Stories  

- As a VM owner, I want the ability to allocate an entire PCI device, including all its functions, to my VM.  
- As a cluster admin, I want a robust solution for generic host device PCI passthrough to VMs.  

## Repositories Impacted  

- [https://github.com/kubevirt/kubevirt](https://github.com/kubevirt/kubevirt)    

## Design  

**Prerequisites:** To understand this enhancement, familiarity with Kubernetes' Dynamic Resource Allocation (DRA) framework and its implementation in KubeVirt is required.
- [DRA in Kubernetes](https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/)
- [Existing DRA implementation in KubeVirt](../10-dra-devices/vep.md)

The existing implementation of DRA in KubeVirt expects a 3rd party DRA driver to be installed in the cluster.  
This driver manages device binding to `vfio` and publishes discovered devices to `ResourceSlice` objects.  
Once a `ResourceSlice` is populated, a `ResourceClaim` object can be created and referenced in the `VirtualMachine` spec.

Currently, KubeVirt does not provide an official DRA driver for generic PCI passthrough.

This enhancement proposal focuses on the following:
- Proposing a design for a generic DRA driver for PCI devices maintained by KubeVirt.
- TODO: prepare a small PoC of a DRA driver using the existing DRA implementation in KubeVirt,  
  in case potential issues that affect this feature come up - document them here

### DRA Driver Design

TODO: Explain the proposed DRA driver design.

### Required KubeVirt Modifictions

TODO: Modifications to KubeVirt's code may be needed after preparing a PoC of a DRA driver - document all required modifications here.  
Hopefully no modification will be required in KubeVirt's repo.  

## API Examples  

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: multifunction-device-claim
---
# Generated by a DRA Driver.
# This driver discovers devices on each node, binds `vfio-pci`, and publishes them to a `ResourceSlice`.
# This ensures the Kubernetes scheduler can access the discovered resources.
apiVersion: resource.k8s.io/v1
kind: ResourceSlice
metadata:
  name: generic-pci-hostdevice-slice
spec:
  driver: generic-pci-hostdevice.kubevirt.com
  nodeName: worker-01
  pool:
    generation: 1
    name: generic-pci-hostdevice-pool
    resourceSliceCount: 1
  devices:
  ##################
  # Physical NIC 1 #
  ##################
  - name: "worker-01-0000:01:00.0"
    attributes:
      resourceName:
        string: "mellanox.com/MT27710_FAMILY_CONNECTX4_LX"
      mdevUuid:
        string: "6fd37ed6-7ed3-49c8-a757-6c5ffaa62bf4"
      resource.kubernetes.io/pcieRoot:
        string: "0000:01"
      resource.kubernetes.io/pciBusID:
        string: "0000:01:00.0"
      # Note that basePciDevice is identical in both 0000:01:00.0 and 0000:01:00.1 but different from 0000:02:00.0 and 0000:02:00.1
      basePciDevice:
        string: "0000:01:00"
  - name: "worker-01-0000:01:00.1"
    attributes:
      resourceName:
        string: "mellanox.com/MT27710_FAMILY_CONNECTX4_LX"
      mdevUuid:
        string: "a83918e9-4054-491d-a233-e96f2bc57449"
      resource.kubernetes.io/pcieRoot:
        string: "0000:01"
      resource.kubernetes.io/pciBusID:
        string: "0000:01:00.1"
      basePciDevice:
        string: "0000:01:00"
  ##################
  # Physical NIC 2 #
  ##################
  - name: "worker-01-0000:02:00.0"
    attributes:
      resourceName:
        string: "mellanox.com/MT27710_FAMILY_CONNECTX4_LX"
      mdevUuid:
        string: "e51f4754-192c-4f22-8972-986674f74a4b"
      resource.kubernetes.io/pcieRoot:
        string: "0000:02"
      resource.kubernetes.io/pciBusID:
        string: "0000:02:00.0"
      # Note that basePciDevice is identical in both 0000:02:00.0 and 0000:02:00.1 but different from 0000:01:00.0 and 0000:01:00.1
      basePciDevice:
        string: "0000:02:00"
  - name: "worker-01-0000:02:00.1"
    attributes:
      resourceName:
        string: "mellanox.com/MT27710_FAMILY_CONNECTX4_LX"
      mdevUuid:
        string: "f76501af-25f1-4a43-a007-b29203ec783e"
      resource.kubernetes.io/pcieRoot:
        string: "0000:02"
      resource.kubernetes.io/pciBusID:
        string: "0000:02:00.1"
      basePciDevice:
        string: "0000:02:00"
  ##################
  #  Physical GPU  #
  ##################
  - name: "worker-01-0000:03:00.0"
    attributes:
      resourceName:
        string: "nvidia.com/TU116_GEFORCE_GTX_1660"
      mdevUuid:
        string: "dedb11ad-c481-4c94-b985-b3bedcc513b6"
      resource.kubernetes.io/pcieRoot:
        string: "0000:03"
      resource.kubernetes.io/pciBusID:
        string: "0000:03:00.0"
      basePciDevice:
        string: "0000:03:00"
  - name: "worker-01-0000:03:00.1"
    attributes:
      resourceName:
        string: "nvidia.com/TU116_HIGH_DEFINITION_AUDIO_CONTROLLER"
      mdevUuid:
        string: "48fb3e3c-4e3f-40c9-811b-1130c55c53a9"
      resource.kubernetes.io/pcieRoot:
        string: "0000:03"
      resource.kubernetes.io/pciBusID:
        string: "0000:03:00.1"
      basePciDevice:
        string: "0000:03:00"
  - name: "worker-01-0000:03:00.2"
    attributes:
      resourceName:
        string: "nvidia.com/TU116_USB_3_1_HOST_CONTROLLER"
      mdevUuid:
        string: "6826e1cf-532f-40c7-9622-cb6a85e2928c"
      resource.kubernetes.io/pcieRoot:
        string: "0000:03"
      resource.kubernetes.io/pciBusID:
        string: "0000:03:00.2"
      basePciDevice:
        string: "0000:03:00"
  - name: "worker-01-0000:03:00.3"
    attributes:
      resourceName:
        string: "nvidia.com/TU116_USB_TYPEC_USCI_CONTROLLER"
      mdevUuid:
        string: "f37c55d2-80c5-4d40-a2f5-346672815088"
      resource.kubernetes.io/pcieRoot:
        string: "0000:03"
      resource.kubernetes.io/pciBusID:
        string: "0000:03:00.3"
      basePciDevice:
        string: "0000:03:00"
---
# Defines the requirements for a claim. In this example,
# the claim will only be satisfied if at least two unallocated functions
# of `mellanox.com/MT27710_FAMILY_CONNECTX4_LX` exist sharing the same `basePciDevice`.
apiVersion: resource.k8s.io/v1
kind: ResourceClaimTemplate
metadata:
  namespace: multifunction-device-claim
  name: mellanox-com-mt27710-family-connectx4-lx-2f-least
spec:
  spec:
    devices:
      requests:
      - name: port-0
        exactly:
          selectors:
            - cel:
                expression: |-
                  device.attributes["generic-pci-hostdevice.kubevirt.com"].resourceName == "mellanox.com/MT27710_FAMILY_CONNECTX4_LX"
      - name: port-1
        exactly:
          selectors:
            - cel:
                expression: |-
                  device.attributes["generic-pci-hostdevice.kubevirt.com"].resourceName == "mellanox.com/MT27710_FAMILY_CONNECTX4_LX"
      # This ensures that all ports belong to the same physical device.
      # Taken from the documentation of `matchAttribute` in the Kubernetes repo itself:
      # ```
      # MatchAttribute requires that all devices in question have this
      # attribute and that its type and value are the same across those
      # devices.
      #
      # For example, if you specified "dra.example.com/numa" (a hypothetical example!),
      # then only devices in the same NUMA node will be chosen. A device which
      # does not have that attribute will not be chosen. All devices should
      # use a value of the same type for this attribute because that is part of
      # its specification, but if one device doesn't, then it also will not be
      # chosen.
      # ```
      matchAttribute: "generic-pci-hostdevice.kubevirt.com/basePciDevice"
---
# Example Pod with 2 dual-port NICs.
# The Pod will be scheduled only when 2 physical ConnectX-4-Lx NICs,
# each with at least 2 ports, are available to the Kubernetes scheduler.
apiVersion: v1
kind: Pod
metadata:
  namespace: multifunction-device-claim
  name: pod-0
spec:
  resourceClaims:
  - name: dual-port-nic-0-port-0
    resourceClaimTemplateName: mellanox-com-mt27710-family-connectx4-lx-2f-least
  - name: dual-port-nic-0-port-1
    resourceClaimTemplateName: mellanox-com-mt27710-family-connectx4-lx-2f-least
  - name: dual-port-nic-1-port-0
    resourceClaimTemplateName: mellanox-com-mt27710-family-connectx4-lx-2f-least
  - name: dual-port-nic-1-port-1
    resourceClaimTemplateName: mellanox-com-mt27710-family-connectx4-lx-2f-least
  containers:
  - name: ctr-0
    image: ubuntu:22.04
    command: ["bash", "-c"]
    args: ["export; trap 'exit 0' TERM; sleep 9999 & wait"]
    resources:
      claims:
      - name: dual-port-nic-0-port-0
        request: port-0
      - name: dual-port-nic-0-port-1
        request: port-1
      - name: dual-port-nic-1-port-0
        request: port-0
      - name: dual-port-nic-1-port-1
        request: port-1
---
# Example VirtualMachineInstance with 1 dual-port NIC.
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
metadata:
  namespace: multifunction-device-claim
  name: vmi-with-2-dual-port-nics
spec:
  resourceClaims:
  - name: dual-port-nic-port-0
    resourceClaimTemplateName: mellanox-com-mt27710-family-connectx4-lx-2f-least
  - name: dual-port-nic-port-1
    resourceClaimTemplateName: mellanox-com-mt27710-family-connectx4-lx-2f-least
  domain:
    devices:
      hostDevices:
      - claimName: dual-port-nic-port-0
        deviceRequestName: port-0
        name: example-dual-port-nic-port-0
      - claimName: dual-port-nic-port-1
        deviceRequestName: port-1
        name: example-dual-port-nic-port-1
```

## Alternatives  

### Alternative 1

Base the solution on the `device-plugin` framework instead of the `DRA` framework.  
Initially this was the first suggestion, but `DRA` was subsequently identified as the preferred path.  

The suggested implementation using the `device-plugin` framework would require editing the `KubeVirtConfiguration.permittedHostDevices` configuration to group multi-function devices as single schedulable units.  
This allows the Kubernetes scheduler to schedule VMs only when the entire group of functions is unallocated.  
When Kubernetes decides to schedule the VM, it owns all functions of the group, and the corresponding Libvirt XML is created.

Although this functions in practice, the downsides are:
- Users cannot easily obtain information about the specific devices allocated to the VM object.
- Groups must be defined prior to VM creation; compared to the DRA approach, this is significantly less flexible.
- This alternative requires code modifications in KubeVirt itself and changes to existing device-plugin General Availability (GA) code.  
  The proposed VEP solution utilizes the original DRA implementation in KubeVirt without these legacy intrusions.

### Alternative 2

Use `DRA` but have the DRA driver publish predefined groups of functions instead of individual function in the `ResourceSlice.spec.devices`.  
This was considered before discovering the `matchAttribute` keyword in the `ResourceClaimTemplate`.  

This alternative improves visibility into allocated devices compared to Alternative 1 but shares the predefined grouping constraint.  
With the discovery of the `matchAttribute` keyword in `ResourceClaimTemplate`, we can achieve dynamic grouping at request time, rendering this alternative unnecessary.  

## Scalability  

This feature has no significant impact on scalability, as it does not introduce complex scheduling logic and leverages KubeVirt's existing host device management code.  

## Update/Rollback Compatibility  

- The proposed changes are upgrade-compatible.  

## Implementation Phases  

TODO: document implementation phases

## Functional Testing Approach  

TODO: document Functional Testing Approach  

## Feature Lifecycle Phases  

A feature gate will not be necessary due to the fact that the core implementation is based on the existing DRA code in KubeVirt.  
